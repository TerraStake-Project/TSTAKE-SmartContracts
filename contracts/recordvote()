event VoteCast(
    uint256 indexed proposalId,
    address indexed voter,
    bool support,
    uint256 weight,
    uint256 forVotes,
    uint256 againstVotes
);

event VoteReason(
    uint256 indexed proposalId,
    address indexed voter,
    string reason
);

function recordVote(uint256 proposalId, bool support, string calldata reason) external nonReentrant {
    Proposal storage proposal = proposals[proposalId];

    // Validate proposal existence and voting period
    require(proposal.voteStart > 0, "Proposal does not exist");
    require(block.timestamp >= proposal.voteStart && block.timestamp <= proposal.voteEnd, "Not in voting period");

    // Validate voter eligibility
    address voter = msg.sender;
    require(!proposal.hasVoted[voter], "Already voted");

    // Use snapshot balance if supported
    uint256 voterBalance = tStakeToken.getPastVotes(voter, proposal.voteStart);
    require(voterBalance >= minimumHolding, "Insufficient token balance to vote");

    // Record the vote
    if (support) {
        proposal.forVotes += voterBalance;
    } else {
        proposal.againstVotes += voterBalance;
    }

    // Mark voter as having voted
    proposal.hasVoted[voter] = true;
    totalVotesCast++;

    // Emit optimized vote event
    emit VoteCast(proposalId, voter, support, voterBalance, proposal.forVotes, proposal.againstVotes);

    // Emit separate event only if reason is provided
    if (bytes(reason).length > 0) {
        require(bytes(reason).length <= 256, "Reason too long");
        emit VoteReason(proposalId, voter, reason);
    }
}



************************************************

event VoteCast(
    uint256 indexed proposalId,
    address indexed voter,
    bool support,
    uint256 weight,
    uint256 forVotes,
    uint256 againstVotes,
    string reason // Included directly in the event
);

***************************************************